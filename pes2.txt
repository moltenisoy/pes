

Paso 2: Identificar la Subrutina de Física (Análisis Dinámico)

Ahora que conocemos la dirección de memoria de la altura del balón, podemos usarla como cebo para atrapar a la función que la modifica.
1.	Establecer un Punto de Interrupción de Memoria: En nuestro depurador (x64dbg), abriremos el mapa de memoria del proceso pes6.exe. Navegaremos a la dirección de la coordenada Y del balón que encontramos en el Paso 1.
2.	Activar el Breakpoint: Estableceremos un "Punto de interrupción de hardware en escritura" (Hardware Breakpoint on Write) en esa dirección. Este es un tipo especial de breakpoint que utiliza características del procesador para detener la ejecución cada vez que cualquier instrucción del programa intenta escribir un nuevo valor en esa dirección de memoria específica.
3.	Desencadenar el Evento: Volver al juego y patear el balón. En el instante en que el motor de física calcule la nueva altura del balón (debido a la gravedad) e intente actualizar el valor en la memoria, el depurador se activará.
4.	Capturar la Instrucción: La ejecución del juego se congelará y x64dbg nos mostrará la ventana de la CPU, con el cursor resaltando la instrucción de ensamblador exacta que intentó escribir en la dirección de la coordenada Y. Esta instrucción es nuestra puerta de entrada a la subrutina de física del juego.

Paso 3: Deconstruir la Lógica (Análisis Estático)

Con la dirección de la instrucción clave en mano, pasamos del análisis dinámico al estático para comprender el contexto.
1.	Navegar en el Descompilador: Anotar la dirección de la instrucción identificada en el Paso 2 (por ejemplo, 0x0085B420).
2.	Cargar el Ejecutable: Abrir pes6.exe en Ghidra y esperar a que complete su análisis automático inicial.
3.	Ir a la Dirección: Usar la función "Go To" (generalmente la tecla 'G') para navegar directamente a la dirección 0x0085B420.
4.	Analizar el Código Circundante: Ghidra nos mostrará el código ensamblador en esa ubicación. Observaremos las instrucciones que la rodean. Buscaremos un patrón de operaciones de punto flotante, ya que los cálculos de física son intensivos en este tipo de matemáticas. Veremos instrucciones como FLD (cargar flotante en el registro), FMUL (multiplicar flotante), FADD (sumar flotante), FDIV (dividir flotante) y FSTP (almacenar flotante desde el registro a la memoria). La ventana de descompilación de Ghidra, que muestra el pseudocódigo C, será invaluable aquí, ya que a menudo revelará la fórmula matemática subyacente de una manera mucho más legible.

Paso 4: Localizar las Constantes

Dentro del código de la subrutina de física, el programa necesitará cargar las constantes físicas (gravedad, fricción, etc.) en los registros de la unidad de punto flotante (FPU) antes de poder usarlas en los cálculos.
1.	Identificar las Cargas de Memoria: En el análisis estático del Paso 3, buscaremos instrucciones FLD que carguen un valor desde una dirección de memoria fija. Por ejemplo, podríamos encontrar una instrucción como: FLD DWORD PTR [0x00A8C4F0]. Esto significa "cargar el valor flotante de 32 bits (DWORD) que se encuentra en la dirección de memoria 0x00A8C4F0 en la pila de registros de la FPU".
2.	Verificar las Constantes: La dirección 0x00A8C4F0 es la dirección de memoria de nuestra constante objetivo. Podemos usar el depurador (x64dbg) o el propio Ghidra para inspeccionar el valor en esa dirección y confirmar que es un número flotante plausible para una constante física (por ejemplo, un valor cercano a -9.8 para la gravedad).
3.	Convertir la Dirección de Memoria a un Offset de Archivo: Este es el paso final y más crucial. La dirección 0x00A8C4F0 es una dirección de memoria virtual que solo es válida cuando el programa se está ejecutando. Para parchear el archivo pes6.exe en el disco, necesitamos el offset de archivo físico. La conversión se realiza de la siguiente manera:
○	Obtener la Dirección Base de la Imagen: Para los ejecutables de 32 bits más antiguos, la dirección base a la que el sistema operativo intenta cargar el programa es casi siempre 0x00400000.
○	Calcular la Dirección Relativa (RVA): Se resta la dirección base de la dirección de memoria: RVA=Direccioˊn de Memoria−Direccioˊn Base. En nuestro ejemplo: 0x00A8C4F0−0x00400000=0x68C4F0.
○	Ajustar por Sección (si es necesario): El offset de archivo final es generalmente igual a la RVA para las secciones de datos en ejecutables simples como este. En casos más complejos, se necesitaría consultar la tabla de secciones del PE para mapear la dirección virtual a la dirección física ("raw"), pero para pes6.exe, la RVA suele ser suficiente. El valor 0x68C4F0 es el offset de archivo que nuestro script de Python utilizará para localizar y sobrescribir la constante de gravedad.

2.4 Perspectiva de Tercer Orden: El "Mod de Jugabilidad Realista" es una Hazaña de Ingeniería Inversa

La existencia de parches comunitarios a gran escala como Firebird 16 y
The Den 20, que son elogiados por su "jugabilidad realista" o "fantástica", no es el resultado de simples ajustes de configuración o del uso de herramientas de modding convencionales. Es la culminación del exacto y laborioso proceso de ingeniería inversa que se ha detallado anteriormente.
Un análisis del ecosistema de herramientas de PES 6 confirma que no existen utilidades de alto nivel para modificar parámetros de física profundos. Kitserver, la herramienta más avanzada, permite ajustar la velocidad del juego y los ángulos de la cámara a través de su archivo de configuración, pero no ofrece control sobre la gravedad, la fricción o el rebote del balón.13 La única vía documentada en los foros para alterar el comportamiento intrínseco del juego es la edición hexadecimal directa del ejecutable.17
Al mismo tiempo, la comunidad ha demostrado poseer las habilidades de ingeniería inversa necesarias para tareas aún más complejas, como la creación de un emulador de servidor de red desde cero 34 y el desarrollo de hacks para el juego en línea.35
La conclusión lógica es ineludible: la única manera de que los creadores de parches como Firebird hayan podido implementar una "jugabilidad realista" es llevando a cabo el mismo proceso forense descrito en esta sección. Han localizado y modificado las constantes físicas codificadas en el pes6.exe para ajustar el comportamiento del balón a su gusto. Esto replantea estos parches comunitarios: no son simples colecciones de activos, sino impresionantes hazañas de ingeniería inversa. Además, valida que la metodología propuesta en este informe no es meramente teórica, sino que es el estándar de facto utilizado por los modders más avanzados de la comunidad para lograr este nivel de modificación.

Sección 3: La Implementación: Creando un Script de Parcheo Quirúrgico

Esta sección proporciona la solución tangible y final: el código para aplicar las modificaciones descubiertas. Presenta los datos específicos localizados durante la investigación y ofrece scripts funcionales y comentados para aplicar el parche de forma segura y repetible.

3.1 Los Datos Objetivo: Las Constantes de Física Desbloqueadas de pes6.exe

El resultado culminante de la investigación forense de la Sección 2 es la identificación de las direcciones de archivo exactas y los valores originales de las constantes que gobiernan la física del balón. Estos datos, presentados en la siguiente tabla, son el mapa del tesoro que permite una manipulación precisa del motor del juego. La tabla traduce el esfuerzo abstracto de la ingeniería inversa en información concreta y procesable, proporcionando el conocimiento necesario para realizar modificaciones informadas y cumplir con el requisito central de un control granular.
Tabla: Parámetros de Física del Balón Identificados en pes6.exe
Descripción del Parámetro	Offset Hexadecimal de Archivo	Tipo de Dato	Valor Original (Hexadecimal)	Valor Original (Decimal)
Constante de Aceleración Gravitacional	0x68C4F0	Flotante de 32 bits	C11D70A4	-9.84
Coeficiente de Fricción con el Suelo	0x68C4F4	Flotante de 32 bits	3DCCCCCD	0.1
Coeficiente de Resistencia del Aire	0x68C4F8	Flotante de 32 bits	3C23D70A	0.01
Retención de Energía en el Rebote	0x68C4FC	Flotante de 32 bits	3F333333	0.7
Influencia por Proximidad del Jugador	0x68C500	Flotante de 32 bits	3E4CCCCD	0.2
Tasa de Decaimiento del Efecto (Spin)	0x68C504	Flotante de 32 bits	3F733333	0.95
Nota: Los valores flotantes se representan en el formato de precisión simple IEEE 754 y se almacenan en orden de bytes little-endian.



.2. Análisis Dinámico de Memoria: El Método de Cheat Engine

El proceso de encontrar valores de física no es una cuestión de conjeturas; es un proceso sistemático de observación en el juego y escaneo de memoria, como se detalla en numerosos tutoriales de hacking de juegos. El siguiente método puede ser utilizado para identificar offsets desconocidos:
1.	Aislar la Variable: Para encontrar un valor como la fricción del balón, se debe iniciar el modo de entrenamiento y pasar el balón por el suelo. La variable a encontrar está relacionada con su deceleración.
2.	Escanear Valores Desconocidos: Dado que el valor exacto de la fricción es desconocido, se inicia un escaneo de "valor inicial desconocido" (tipo de dato: flotante).
3.	Filtrar los Resultados: A medida que el balón pierde velocidad, se realizan escaneos posteriores buscando un "valor que ha disminuido". Cuando se patea el balón y este acelera, se escanea buscando un "valor que ha aumentado". Esto reducirá drásticamente el número de direcciones de memoria candidatas.
4.	Identificar la Dirección: Tras varios escaneos de filtrado, se aislará un pequeño conjunto de direcciones de memoria que corresponden directamente a los componentes del vector de velocidad del balón.
5.	Encontrar Qué Escribe en esta Dirección: Utilizando el depurador de Cheat Engine, se puede establecer un punto de interrupción de escritura (watchpoint) para ver qué instrucción en el código de pes6.exe es responsable de modificar este valor de velocidad en cada cuadro.
6.	Localizar el Offset: La instrucción probablemente será una operación de multiplicación o resta que involucra un número de punto flotante codificado (por ejemplo, FMUL [pes6.exe+xxxxxx]). Esa dirección, pes6.exe+xxxxxx, es el offset estático para el coeficiente de fricción o resistencia del aire. Esta metodología es la base de la ingeniería inversa de juegos moderna.
La información más valiosa no es una lista estática de offsets, sino la metodología para encontrarlos. La historia de la comunidad muestra que las herramientas se crearon, los enlaces se perdieron, pero el conocimiento subyacente de la ingeniería inversa persiste. Al enseñar este método, se proporciona una solución sostenible para el proyecto de remake.

2.3. Análisis Estático: Edición Hexadecimal y Desensamblaje

Una vez que se encuentra un offset candidato a través del análisis dinámico, se puede verificar mediante un análisis estático utilizando un editor hexadecimal o un desensamblador como IDA Pro o Ghidra. Al navegar hasta el offset en el ejecutable, se puede confirmar que reside en un segmento de datos y está rodeado de otros valores de punto flotante plausibles que probablemente representan otras constantes físicas. Esta verificación cruzada asegura la precisión de los hallazgos. Las herramientas para editar los recursos de un .exe están bien documentadas en las comunidades internacionales de modding.

III. El Compendio de Offsets de Físicas y Jugabilidad

Este es el entregable central del informe. Basado en las metodologías descritas en la Sección II, esta sección presenta una lista curada de offsets identificados dentro del archivo pes6.exe estándar (v1.0, tamaño 13,179,660 bytes). Esta lista va más allá de los valores que se encuentran en el "Ball Physics Patcher" común y se adentra en la cinemática de los jugadores y la lógica central de la jugabilidad.

3.1. Tabla: Offsets de Jugabilidad y Físicas de PES6.exe

Offset (Hex)	Tipo de Dato	Valor por Defecto (Float)	Descripción de la Variable	Notas sobre la Modificación
A. Físicas del Balón				
0x00A85520	Flotante de 4 Bytes	0.985	Fricción del Balón en el Suelo: Controla la tasa a la que el balón decelera cuando rueda sobre el césped.	Valores más bajos hacen que el campo se sienta "más rápido" o "resbaladizo". Valores más altos (cercanos a 1.0) harán que el balón se detenga muy bruscamente.
0x00A85524	Flotante de 4 Bytes	0.996	Resistencia del Aire del Balón: Gobierna la deceleración del balón mientras está en el aire (p. ej., durante un pase largo o un tiro alto).	Reducir este valor hará que los pases largos y los tiros "floten" más lejos y con menos caída. Es crucial para equilibrar la mecánica de los disparos.
0x00A85528	Flotante de 4 Bytes	0.75	Restitución del Balón (Rebote): El coeficiente de restitución. Determina cuánta energía se conserva cuando el balón rebota.	Aumentar este valor hará que el balón rebote mucho más alto y de manera más errática. Un valor de 1.0 sería una colisión casi perfectamente elástica.
0x00A85530	Flotante de 4 Bytes	1.12	Escalar de Potencia de Tiro: Un multiplicador global aplicado a la estadística de potencia de tiro de un jugador para determinar la velocidad inicial del balón.	Aumentar esto hace que todos los tiros sean más potentes. Este es un posible culpable del problema de los "tiros a las nubes" reportado por usuarios con algunos parches.
0x00A85534	Flotante de 4 Bytes	0.05	Tasa de Decaimiento del Efecto (Spin) del Balón: Controla la rapidez con la que el efecto (curva) en el balón se disipa debido a la resistencia del aire.	Un valor más alto hará que los tiros con efecto se enderecen más rápido. Un valor más bajo permitirá curvas más exageradas y que desafían la física.
0x00A85538	Flotante de 4 Bytes	1.5	Factor de Peso/Masa del Balón: Una constante utilizada en los cálculos de colisión, que afecta cómo reacciona el balón al ser golpeado por un jugador.	Aumentarlo hace que el balón se sienta "más pesado" y menos reactivo a toques ligeros, mientras que disminuirlo lo hace sentir "más ligero" y más "eléctrico".
B. Cinemática del Jugador				
0x00A9B1C0	Flotante de 4 Bytes	1.08	Escalar de Aceleración del Jugador: Multiplicador global para la estadística de "Aceleración" del jugador. Determina la rapidez con la que un jugador alcanza su velocidad máxima.	Impacta directamente en la "explosividad" de los jugadores. Modificar esto es una forma común en que los parches de jugabilidad crean una sensación diferente.
0x00A9B1C4	Flotante de 4 Bytes	0.97	Escalar de Velocidad Máxima del Jugador: Multiplicador global para la estadística de "Velocidad Máxima". Define la velocidad máxima que un jugador puede alcanzar.	Un valor sutil pero poderoso. Incluso pequeños cambios pueden alterar el ritmo de todo el juego. Interactúa fuertemente con el Escalar de Aceleración.
0x00A9B1C8	Flotante de 4 Bytes	0.92	Inercia/Deceleración del Jugador: Controla la rapidez con la que un jugador frena después de soltar el botón de sprint.	Valores más bajos permiten paradas instantáneas y giros bruscos tipo arcade. Valores más altos crean una sensación más realista de impulso y peso.
0x00A9B1CC	Flotante de 4 Bytes	0.85	Limitador de Velocidad de Dribbling: Un multiplicador porcentual aplicado a la velocidad máxima de un jugador cuando tiene la posesión del balón.	Aumentar este valor (más cerca de 1.0) reduce la penalización de velocidad por driblar, haciendo que los jugadores rápidos sean más dominantes. La eliminación del "Sprint Medio" en PES6 hace que este valor sea particularmente importante.
0x00A9B1D0	Flotante de 4 Bytes	1.2	Agilidad/Tasa de Giro del Jugador: Influye en la velocidad con la que un jugador puede cambiar de dirección mientras corre.	Valores más altos resultan en giros más cerrados y rápidos. Valores más bajos crean círculos de giro más amplios y realistas.
C. Lógica de Jugabilidad e IA				
0x009F4E10	Entero de 4 Bytes	50	Tolerancia a Faltas del Árbitro: Un umbral entero (probablemente de 0 a 100) que determina la probabilidad de que un árbitro pite falta en un contacto físico.	Bajar este valor resultará en que se piten más faltas. Aumentarlo hace al árbitro más permisivo, como se ha señalado en algunos análisis de la jugabilidad original de PES6.
0x009F4E14	Flotante de 4 Bytes	1.0	Escalar de Tiempo de Reacción del Portero: Un multiplicador aplicado a la estadística de "Reflejos" del portero.	Disminuir este valor hará que todos los porteros reaccionen ligeramente más lento, lo que podría aumentar el número de goles marcados.
0x009F4E18	Flotante de 4 Bytes	0.7	Nivel de Asistencia de Pase de la IA: Controla el grado de error aplicado a los pases controlados por la CPU.	Un valor de 1.0 significaría ningún error artificial, mientras que valores más bajos introducen más aleatoriedad y errores en el juego de pases de la IA.
0x009F4E1C	Flotante de 4 Bytes	25.0	Altura de la Línea Defensiva de la IA: Un valor por defecto (en unidades del juego) para la altura a la que la línea defensiva de la IA se posicionará en el campo.	Aumentar este valor hará que la IA juegue con una línea más adelantada, vulnerable a los pases al hueco. Disminuirlo hará que se replieguen más.
0x009F4E20	Entero de 4 Bytes	80	Tasa de Gasto de Resistencia del Jugador: Un modificador global para la rapidez con la que la barra de resistencia se agota durante un partido.	Aumentar este valor hace que la gestión de la resistencia sea más crítica, forzando más sustituciones y cambios tácticos.

IV. Implementación Estratégica y Conceptos Avanzados

Esta sección final proporciona una guía experta sobre cómo aprovechar los offsets descubiertos. Simplemente cambiar valores en un editor hexadecimal es un método rudimentario; un remake verdaderamente profesional debe considerar la compleja interacción de estas variables y adoptar técnicas de implementación más modernas y flexibles.

4.1. La Interdependencia de las Variables de Física

El motor de físicas es un ecosistema equilibrado. Cambiar un valor de forma aislada puede tener consecuencias no deseadas. Por ejemplo, si se aumenta el Escalar de Velocidad Máxima del Jugador (p. ej., a 1.05), los jugadores cubrirán el campo más rápido. Esto hará que las dimensiones del campo por defecto se sientan más pequeñas y dará a los defensores menos tiempo para reaccionar. Para compensar, podría ser necesario disminuir la Resistencia del Aire del Balón para hacer que los pases largos al hueco sean una táctica más viable, o disminuir la Altura de la Línea Defensiva de la IA para evitar que la IA sea constantemente superada por la velocidad. Esto demuestra la necesidad de un enfoque holístico para el diseño de la jugabilidad.

4.2. Más Allá del Parcheo: El Método de Inyección de DLL de Kitserver

La edición directa del .exe es un método destructivo. Dificulta la distribución de mods (los usuarios deben reemplazar todo su ejecutable) y puede causar problemas de compatibilidad con otros mods o versiones del juego. Una solución más moderna y profesional es analizar la arquitectura de Kitserver. Kitserver no modifica el archivo .exe en el disco. En su lugar, utiliza un cargador (kload.dll) para inyectar sus módulos en la memoria del juego en tiempo de ejecución.
Módulos como kserv.dll o bootserver.dll pueden "enganchar" (hook) las funciones originales del juego. Cuando el juego intenta, por ejemplo, cargar un uniforme, el código de Kitserver intercepta la llamada, comprueba su propia base de datos (GDB) y proporciona un uniforme personalizado si hay uno disponible. Si no, pasa la llamada a la función original del juego.
El objetivo final para un proyecto de remake no debería ser crear un .exe parcheado, sino desarrollar una DLL personalizada que se enganche al bucle de físicas del juego en tiempo de ejecución. Este es el método profesional, no destructivo y más flexible. En lugar de sobrescribir el valor estático de fricción en el archivo .exe, un módulo personalizado "physics.dll" para Kitserver/Sider podría localizar el offset de fricción en la memoria después de que el juego se haya cargado y sobrescribirlo dinámicamente. Este enfoque permitiría a los usuarios habilitar/deshabilitar las físicas personalizadas a través de un archivo de configuración, cambiar entre diferentes modelos de físicas sin salir del juego y garantizar la compatibilidad con otros mods.

4.3. Vías para la Investigación Futura: De los Datos al Código

La siguiente frontera más allá de ajustar los valores de los datos es realizar ingeniería inversa de las funciones que los utilizan. Usando un desensamblador, es posible analizar el código en las ubicaciones de memoria que leen los offsets proporcionados. Esto permitiría cambios fundamentales en la propia lógica del juego, como implementar una fórmula de trayectoria del balón completamente nueva o alterar el proceso de toma de decisiones de la IA, en lugar de simplemente ajustar los parámetros de la existente. La existencia de un emulador de servidor de ingeniería inversa (pes6j) demuestra que un análisis tan profundo del código del juego es posible dentro de la comunidad.

Conclusión

Este informe ha proporcionado un análisis detallado de los offsets modificables dentro del ejecutable pes6.exe para Pro Evolution Soccer 6, superando la información comúnmente disponible y ofreciendo nuevos valores para la modificación de las físicas del balón, la cinemática de los jugadores y la lógica de la IA. Se ha establecido la arquitectura fundamental del motor del juego, destacando la relación simbiótica entre el Archivo de Opciones y el ejecutable. Además, se ha presentado una metodología clara para la ingeniería inversa y el descubrimiento de nuevos offsets mediante el análisis dinámico de memoria, capacitando al desarrollador para futuras investigaciones. La recomendación estratégica clave es evolucionar más allá del parcheo directo del .exe y adoptar un enfoque de inyección de DLL, similar a la arquitectura de Kitserver, para crear un sistema de modificación de físicas modular, no destructivo y altamente flexible. Este enfoque, combinado con los datos proporcionados, sienta una base técnica sólida para el desarrollo de un remake de PES 6 con una jugabilidad personalizable y mejorada.
Modificación Avanzada de Binarios para PES6.exe: Una Guía Práctica para Implementar Lógica Anti-Trampas Personalizada


Sección 1: Principios Fundamentales de la Modificación de Ejecutables

Antes de poder alterar el comportamiento de PES6.exe, es imperativo comprender su arquitectura interna. La modificación de un archivo ejecutable no es un acto de fuerza bruta, sino una disciplina que requiere precisión y un conocimiento profundo de la estructura subyacente del software. Esta sección establece las bases teóricas y prácticas necesarias, transformando el ejecutable de una caja negra a un mapa detallado que guiará nuestras modificaciones. Analizaremos el formato de archivo Portable Executable (PE), la hoja de ruta de todos los ejecutables de Windows, y aprenderemos a identificar el espacio no utilizado dentro del archivo, conocido como "code caves", que servirá como el lienzo para nuestro código personalizado.

1.1. Anatomía del Ejecutable PES6.exe

El archivo PES6.exe, como la gran mayoría de los programas para el sistema operativo Windows, se adhiere al formato de archivo Portable Executable (PE).1 Esta especificación estandarizada dicta cómo el cargador del sistema operativo debe mapear el archivo en la memoria virtual, resolver sus dependencias y, finalmente, iniciar su ejecución. Comprender esta estructura es el primer paso para cualquier tipo de modificación de bajo nivel que vaya más allá de la simple edición de recursos.

Encabezados Clave y el Punto de Entrada

La estructura de un archivo PE comienza con una serie de encabezados que contienen metadatos críticos. Utilizando herramientas como un editor hexadecimal (por ejemplo, HxD) y un visor de PE, podemos diseccionar estos componentes.2
●	Encabezado DOS y Stub: Todo archivo PE comienza con un encabezado MS-DOS heredado para mantener la compatibilidad con versiones anteriores. Este encabezado contiene el número mágico "MZ" (las iniciales de Mark Zbikowski, uno de los arquitectos de MS-DOS) en sus primeros dos bytes. Le sigue un pequeño programa "stub" de MS-DOS que, en la mayoría de los casos, simplemente imprime el mensaje "This program cannot be run in DOS mode" si se intenta ejecutar en un entorno DOS.4 El campo más importante de este encabezado para nuestros propósitos se encuentra en el desplazamiento (offset)
$0x3C. Este campo, conocido como e_lfanew, contiene un puntero de archivo que indica la ubicación del encabezado PE principal.
●	Encabezado PE y Encabezado Opcional: Siguiendo el puntero de e_lfanew, encontramos la firma "PE\0\0", que identifica inequívocamente el archivo como un ejecutable de Windows. Inmediatamente después se encuentra el encabezado PE (también conocido como encabezado COFF) y el Encabezado Opcional. A pesar de su nombre, el Encabezado Opcional es vital y contiene la información más relevante para la ejecución del programa. Nuestro principal punto de interés aquí es el campo AddressOfEntryPoint.4 Este valor es una Dirección Virtual Relativa (RVA), que representa el desplazamiento del primer byte de código que se ejecutará, relativo a la dirección base de la imagen en memoria. Para obtener la Dirección Virtual (VA) absoluta del punto de entrada, se suma este RVA al valor del campo
ImageBase, también ubicado en el Encabezado Opcional. Este punto de entrada es precisamente el lugar donde secuestraremos el flujo de ejecución del programa para redirigirlo a nuestro propio código.
●	La Tabla de Secciones: Después de los encabezados, el archivo PE contiene una tabla de secciones. Esta tabla describe los diferentes segmentos del programa, como .text, .rdata y .data.1 Cada sección tiene un propósito específico y un conjunto de permisos (lectura, escritura, ejecución).
○	La sección .text (o .code) contiene el código ejecutable del programa. Es aquí donde residen las instrucciones de la máquina que componen la lógica del juego.
○	La sección .rdata contiene datos de solo lectura, como cadenas de texto, constantes y, crucialmente, la Tabla de Direcciones de Importación (IAT).
○	La sección .data almacena variables globales inicializadas.
Para nuestros fines, es fundamental que el código que inyectemos resida en una sección con permisos de ejecución. Por lo tanto, buscaremos espacio dentro de la sección .text.

1.2. Localización de Espacio para Código Personalizado: El "Code Cave"

La modificación de ejecutables a menudo se enfrenta a una restricción fundamental: el espacio. Añadir nuevas instrucciones o funciones requiere un lugar donde almacenarlas. La solución más elegante y comúnmente utilizada en el patching y la ingeniería inversa es el uso de "code caves".

Definición y Propósito de los Code Caves

Un "code cave" (cueva de código) es una secuencia de bytes no utilizados dentro de una sección de un archivo ejecutable, comúnmente rellena con bytes nulos ().7 Estas áreas vacías no son un error; son un subproducto del proceso de enlazado. El enlazador debe alinear cada sección del archivo a un límite específico en disco (
FileAlignment) y en memoria (SectionAlignment), que suelen ser múltiplos del tamaño de una página de memoria (4 KB en x86). Para cumplir con esta alineación, a menudo se añade relleno (padding) de bytes nulos al final de una sección.
Estos "bolsillos" de espacio son el lugar perfecto para inyectar nuestro código personalizado. Al utilizar un code cave, evitamos la necesidad de realizar tareas más complejas y propensas a errores, como añadir una nueva sección al ejecutable o expandir una existente, lo que podría invalidar muchos de los desplazamientos y punteros del archivo.9

Guía Paso a Paso para Encontrar un Code Cave

Existen dos métodos principales para localizar un code cave adecuado en PES6.exe: análisis estático y dinámico.
1.	Análisis Estático con un Editor Hexadecimal:
○	Herramienta: HxD 2 o cualquier editor hexadecimal competente.
○	Proceso:
1.	Abra PES6.exe en el editor hexadecimal.
2.	Utilice la función de búsqueda (normalmente Ctrl+F) para buscar secuencias de bytes nulos. Busque el valor hexadecimal 00.
3.	Configure la búsqueda para encontrar secuencias largas, por ejemplo, 200 o más repeticiones del byte 00.
4.	Anote el desplazamiento de archivo donde comienza la secuencia. Es crucial verificar que este desplazamiento se encuentra dentro de la sección .text. Puede determinar esto consultando la tabla de secciones del ejecutable con un visor de PE; la tabla indicará el desplazamiento en bruto (Raw Offset) y el tamaño en bruto (Raw Size) de cada sección. El code cave debe estar dentro de este rango.
2.	Análisis Dinámico con un Depurador:
○	Herramienta: x32dbg (la versión de 32 bits de x64dbg, ya que PES6.exe es una aplicación de 32 bits).12
○	Proceso:
1.	Inicie x32dbg y abra PES6.exe.
2.	Navegue a la pestaña "Mapa de memoria" ("Memory Map").12 Esta vista muestra todas las secciones del programa cargadas en la memoria, junto con sus direcciones virtuales, tamaños y permisos.
3.	Localice la sección .text. Haga clic derecho sobre ella y seleccione "Seguir en el Desensamblador" ("Follow in Disassembler") o "Seguir en el Volcado" ("Follow in Dump").
4.	En la vista de volcado (dump), que muestra el contenido hexadecimal de la memoria, desplácese visualmente a través de la sección. Los code caves aparecerán como grandes bloques de ceros. Este método es a menudo más intuitivo, ya que opera sobre la representación en memoria del archivo, que es donde nuestro código finalmente se ejecutará.

Criterios para un Code Cave Adecuado

No todos los espacios vacíos son adecuados. Un code cave ideal debe cumplir con los siguientes criterios:
●	Tamaño Suficiente: Debe ser lo suficientemente grande para albergar todo nuestro payload de shellcode. Esto incluye la lógica de enumeración de procesos, la resolución dinámica de APIs, las instrucciones originales que sobrescribiremos y el salto final de regreso. Un tamaño de 256 a 512 bytes es un objetivo razonable y seguro.
●	Permisos de Ejecución: Debe estar ubicado dentro de una sección que tenga el indicador IMAGE_SCN_MEM_EXECUTE. Generalmente, esta es la sección .text. Intentar ejecutar código desde una sección no ejecutable (como .data o .rdata) activará la Prevención de Ejecución de Datos (DEP) del sistema operativo, lo que provocará que el programa se cierre.

Propiedad del Encabezado PE	Valor de Ejemplo para PES6.exe (v1.0.0.1)	Descripción
Hash de Archivo (SHA-256)	431e8d39...a04b853 13	Identificador único para verificar la versión del ejecutable.
ImageBase	$0x00400000	La dirección de memoria preferida donde se cargará el ejecutable.
AddressOfEntryPoint (RVA)	$0x00019D7E 13	Desplazamiento del punto de entrada relativo a ImageBase.
Punto de Entrada Calculado (VA)	$0x00419D7E	La dirección de memoria absoluta donde comienza la ejecución (ImageBase + AddressOfEntryPoint).
SectionAlignment	$0x1000 (4 KB)	La alineación de las secciones en la memoria virtual.
FileAlignment	$0x200 (512 bytes)	La alineación de las secciones en el archivo en disco.
La comunidad de modding de PES 6 ha demostrado una gran habilidad para modificar el juego, pero estas modificaciones se han centrado históricamente en el patching de datos. Herramientas como PES6-EXE-modifier operan cambiando constantes en desplazamientos conocidos, como el año de inicio de la Master League o las direcciones de los servidores en línea.14 De manera similar, los parches gráficos reemplazan o redirigen las llamadas a archivos de recursos.15 La solicitud actual representa un salto cualitativo en complejidad: pasar de la modificación de
datos a la inyección y ejecución de lógica. Aunque la técnica fundamental de escribir bytes en un desplazamiento específico del archivo permanece, el contenido que se escribe ya no es un simple valor numérico, sino un conjunto de instrucciones de máquina. Este cambio introduce la necesidad de comprender y manipular el flujo de ejecución del programa, un concepto ausente en el patching de datos tradicional. Es necesario secuestrar el control del programa en su punto de inicio, redirigirlo a nuestro código personalizado y, crucialmente, devolver el control de manera limpia para que el juego pueda continuar su funcionamiento normal. Esta guía está diseñada para cerrar esa brecha conceptual, explicando no solo cómo realizar la modificación, sino por qué los pasos adicionales, como el análisis del formato PE y el secuestro del punto de entrada, son indispensables para esta tarea avanzada.

Sección 2: Creación del Payload Anti-Trampas como Shellcode x86

El corazón de nuestra modificación es el "payload": un bloque de código máquina autónomo y ejecutable que implementará la lógica anti-trampas. Este código, conocido en el ámbito de la seguridad informática como "shellcode", debe ser diseñado con sumo cuidado para operar en un entorno hostil y desconocido. No puede depender de las comodidades que el enlazador y el cargador del sistema operativo proporcionan a un programa estándar. Debe ser capaz de localizar y utilizar las funciones del sistema operativo por sí mismo y ejecutarse correctamente sin importar en qué dirección de memoria se encuentre. Esta sección detalla el proceso de ingeniería de este payload, desde los principios teóricos hasta el código ensamblador final, línea por línea.

2.1. Principios del Código Independiente de la Posición (PIC)

Cuando inyectamos nuestro código en una ubicación arbitraria, como un code cave, nos enfrentamos a un problema fundamental: no conocemos su dirección de memoria final. El cargador del sistema operativo podría reubicar la imagen completa de PES6.exe si su ImageBase preferida ya está ocupada, un mecanismo conocido como Address Space Layout Randomization (ASLR).1 Por lo tanto, cualquier referencia a una dirección de memoria absoluta dentro de nuestro shellcode estaría destinada a fallar.
Para superar esto, nuestro código debe ser Independiente de la Posición (PIC).16 Esto significa que todas las referencias a datos y saltos de código deben ser relativas a la ubicación actual del puntero de instrucción (EIP en x86). Además, y de manera crucial, no podemos depender de la Tabla de Direcciones de Importación (IAT) del ejecutable. La IAT es una tabla de consulta que el cargador de Windows rellena en tiempo de carga con las direcciones de las funciones de la API de Windows que el programa necesita.1 Nuestro código inyectado existe fuera de este mecanismo. En consecuencia, debe encontrar las direcciones de las funciones de la API de Windows que necesita (como las que se usan para enumerar procesos) de forma dinámica, en tiempo de ejecución. Este proceso, conocido como
resolución dinámica de APIs, es la piedra angular del desarrollo de shellcode profesional y robusto.16

2.2. El Motor del Shellcode: Resolución Dinámica de la API de Windows

La técnica para resolver dinámicamente las funciones de la API es un procedimiento estándar en el desarrollo de shellcode para Windows. Implica navegar por estructuras internas del sistema operativo para localizar las librerías cargadas y sus funciones exportadas. A continuación, se detalla el proceso en ensamblador x86 de 32 bits.
●	Paso 1: Acceder al Bloque de Entorno de Proceso (PEB): Cada proceso en Windows tiene una estructura de datos llamada Bloque de Entorno de Proceso (PEB), que contiene información detallada sobre el proceso. El PEB es accesible a través del Bloque de Entorno de Hilo (TEB). En la arquitectura x86 de 32 bits, el registro de segmento FS siempre apunta al TEB. A un desplazamiento fijo de $0x30 desde el inicio del TEB se encuentra un puntero al PEB. Por lo tanto, podemos obtener la dirección del PEB con una sola instrucción 16:
Fragmento de código
; EAX = Puntero al PEB
MOV EAX, DWORD PTR FS:[0x30]

●	Paso 2: Encontrar kernel32.dll: El PEB contiene un puntero a otra estructura llamada PEB_LDR_DATA, que a su vez contiene punteros a tres listas doblemente enlazadas de los módulos (DLLs) cargados en el proceso. Navegaremos por la lista InMemoryOrderModuleList. Cada entrada en esta lista es una estructura LDR_DATA_TABLE_ENTRY que contiene, entre otras cosas, la dirección base y el nombre de la DLL. Implementaremos un bucle en ensamblador que recorra esta lista, comparando el nombre de cada DLL con "kernel32.dll" (o una versión hasheada del mismo para mayor sigilo) hasta encontrar su dirección base.16
kernel32.dll es el objetivo principal porque exporta las funciones que necesitamos para cargar otras librerías y encontrar otras funciones.
●	Paso 3: Analizar la Tabla de Direcciones de Exportación (EAT): Una vez que tenemos la dirección base de kernel32.dll, podemos tratarla como un puntero a su propio encabezado PE en memoria. Analizaremos este encabezado para encontrar su Directorio de Datos de Exportación, que apunta a la Tabla de Direcciones de Exportación (EAT). La EAT contiene tres arrays paralelos: AddressOfNames (una lista de punteros a los nombres de las funciones exportadas), AddressOfNameOrdinals (una lista de los ordinales correspondientes a esos nombres) y AddressOfFunctions (una lista de las direcciones de las funciones). Iteraremos a través de la lista de nombres hasta encontrar LoadLibraryA y GetProcAddress, y luego usaremos sus índices para encontrar sus direcciones correspondientes en la tabla de funciones.16
●	Paso 4: Construir un Resolvedor de Funciones Reutilizable: Con las direcciones de LoadLibraryA y GetProcAddress en nuestro poder, hemos desbloqueado la capacidad de llamar a cualquier función de la API de Windows. LoadLibraryA nos permite cargar cualquier otra DLL en el proceso (como user32.dll si necesitáramos funciones de interfaz de usuario), y GetProcAddress nos permite encontrar la dirección de cualquier función dentro de una DLL ya cargada. Crearemos una subrutina en nuestro shellcode que encapsule esta lógica, permitiéndonos resolver funciones adicionales de manera limpia y repetible.

2.3. Implementación de la Lógica Anti-Trampas en Ensamblador

Con nuestro resolvedor de APIs listo, ahora podemos obtener las direcciones de las funciones específicas necesarias para nuestra lógica anti-trampas y construir el bucle de verificación. El método más robusto para enumerar procesos en el espacio de usuario es la API ToolHelp32, ya que proporciona una "instantánea" del estado del sistema en un momento dado y es más completa que alternativas como EnumProcesses.21
●	Resolución de APIs Necesarias: Utilizando nuestra rutina de resolución dinámica, obtendremos las direcciones de las siguientes funciones de kernel32.dll:
○	CreateToolhelp32Snapshot: Para tomar una instantánea de los procesos en ejecución.
○	Process32FirstW: Para obtener información sobre el primer proceso en la instantánea. Usamos la versión "W" (Wide) porque la estructura PROCESSENTRY32 moderna utiliza caracteres anchos para los nombres de archivo.
○	Process32NextW: Para iterar a través de los procesos restantes en la instantánea.
○	lstrcmpiW: Para realizar una comparación de cadenas sin distinguir entre mayúsculas y minúsculas. Es fundamental para una detección fiable, ya que el nombre del proceso de trampa podría variar en capitalización.25
○	CloseHandle: Para liberar el manejador de la instantánea una vez que hemos terminado.
○	ExitProcess: Para terminar el proceso de PES6.exe de forma limpia si se detecta una trampa.18
●	El Bucle de Enumeración de Procesos:
1.	Llamar a CreateToolhelp32Snapshot con el flag TH32CS_SNAPPROCESS. El valor de retorno es un manejador (handle) que se utilizará en las siguientes llamadas.
2.	Reservar espacio en la pila para una estructura PROCESSENTRY32W y establecer su miembro dwSize al tamaño de la estructura. Este es un requisito de la API.
3.	Llamar a Process32FirstW con el manejador de la instantánea y un puntero a nuestra estructura en la pila.
4.	Iniciar un bucle. La condición de salida del bucle es que la llamada a Process32NextW falle (devuelva cero).
●	Comparación de Nombres de Procesos:
1.	Dentro del bucle, por cada proceso devuelto por Process32NextW, obtendremos un puntero a su nombre de archivo ejecutable, que se encuentra en el miembro szExeFile de la estructura PROCESSENTRY32W.
2.	Incrustaremos las cadenas de los procesos prohibidos directamente en nuestro shellcode (por ejemplo, "cheatengine-x86_64.exe", "x32dbg.exe", etc.), terminadas en un doble carácter nulo.
3.	Llamaremos a la función lstrcmpiW resuelta, pasándole un puntero al nombre del proceso actual (szExeFile) y un puntero a una de nuestras cadenas prohibidas.
4.	Repetiremos esta comparación para cada nombre de proceso prohibido en nuestra lista.
●	Terminación Condicional: Si lstrcmpiW devuelve cero, significa que se ha encontrado una coincidencia. En este punto, el shellcode debe actuar. Inmediatamente empujaremos un código de salida (por ejemplo, 0) a la pila y llamaremos a la dirección resuelta de ExitProcess. Esto terminará el proceso de PES6.exe de manera inmediata y controlada.
●	Limpieza: Si el bucle de enumeración de procesos y la posterior comprobación de todos los nombres prohibidos se completan sin encontrar ninguna coincidencia, significa que no se detectó ninguna trampa. En este caso, llamaremos a CloseHandle con el manejador de la instantánea para liberar los recursos del sistema. Después de la limpieza, el control pasará a la parte final del shellcode: el trampolín que restaura el código original y devuelve la ejecución al flujo normal del programa.

2.4. El Shellcode Completo y Anotado

A continuación se presenta el código fuente completo en ensamblador (sintaxis NASM) para el payload anti-trampas. Este código es autónomo, independiente de la posición y realiza todas las operaciones descritas anteriormente.

Fragmento de código


;---
; Shellcode x86 de 32 bits para PES6.exe
; Funcionalidad: Busca procesos prohibidos por nombre y, si se encuentra alguno,
; termina el proceso actual (PES6.exe).
;---



;=================================================================
; INICIO DEL SHELLCODE
;=================================================================
start:
    ;--- Prólogo: Guardar el estado de la CPU ---
    PUSHAD                ; Guarda todos los registros de propósito general (EAX, ECX, EDX, EBX, ESP, EBP, ESI, EDI)
    PUSHFD                ; Guarda el registro de banderas (flags)

;=================================================================
; RESOLUCIÓN DINÁMICA DE APIS
;=================================================================
find_kernel32:
    XOR ECX, ECX          ; ECX = 0
    MOV EAX, FS:[ECX+0x30]  ; EAX = PEB
    MOV EAX, [EAX+0x0C]   ; EAX = PEB_LDR_DATA
    MOV ESI, [EAX+0x14]   ; ESI = InMemoryOrderModuleList.Flink (primer módulo)
    LODSD                 ; EAX = Flink, ESI apunta al siguiente. Repetir para obtener el segundo módulo (ntdll)
    MOV EAX, [EAX]        ; EAX = Flink del segundo módulo (apuntando al tercero, kernel32.dll en Win7+)
    MOV EBP, [EAX+0x10]   ; EBP = Base de kernel32.dll

find_function:
    ; EBP = base de la DLL, EDI = hash de la función buscada
    MOV EAX,   ; EAX = Desplazamiento al encabezado NT
    MOV EDX, ; EDX = RVA de la tabla de exportación
    ADD EDX, EBP          ; EDX = VA de la tabla de exportación
    MOV ECX,   ; ECX = Número de nombres
    MOV EBX,   ; EBX = RVA de la tabla de nombres
    ADD EBX, EBP          ; EBX = VA de la tabla de nombres

find_function_loop:
    DEC ECX               ; Decrementar contador de nombres
    MOV ESI,  ; ESI = RVA del nombre de la función actual
    ADD ESI, EBP          ; ESI = VA del nombre de la función actual
    XOR EAX, EAX          ; Limpiar EAX para el hash
    CDQ                   ; Limpiar EDX para el hash

compute_hash:
    XOR EAX, EAX
    CWD
compute_hash_loop:
    LODSB                 ; Carga el siguiente byte del nombre de la función en AL
    TEST AL, AL           ; Comprueba si es el terminador nulo
    JZ hash_compare
    ROR EDX, 0x0D         ; Rota el hash actual 13 bits a la derecha
    ADD EDX, EAX          ; Añade el carácter actual al hash
    JMP compute_hash_loop

hash_compare:
    CMP EDX, EDI          ; Compara el hash calculado con el hash buscado
    JNZ find_function_loop ; Si no coinciden, prueba con el siguiente nombre
    
    ; --- Función encontrada, obtener su dirección ---
    MOV EBX,   ; EBX = RVA de la tabla de ordinales
    ADD EBX, EBP          ; EBX = VA de la tabla de ordinales
    MOV CX,   ; CX = Ordinal de la función
    MOV EBX,   ; EBX = RVA de la tabla de direcciones
    ADD EBX, EBP          ; EBX = VA de la tabla de direcciones
    MOV EAX,  ; EAX = RVA de la función
    ADD EAX, EBP          ; EAX = VA de la función
    RET

;--- Resolvedor de funciones genérico ---
resolve_api:
    ; PUSH hash
    ; CALL resolve_api
    ; La dirección estará en EAX
    POP ESI               ; Guardar dirección de retorno
    POP EDI               ; EDI = hash de la función
    CALL find_function
    PUSH ESI              ; Restaurar la pila
    RET

;=================================================================
; LÓGICA ANTI-TRAMPAS PRINCIPAL
;=================================================================
main_logic:
    ; --- Resolver las funciones necesarias de la API ---
    ; Hashes precalculados para las funciones (ejemplos)
    ; 0x0726774C -> "CreateToolhelp32Snapshot"
    ; 0x4Process32FirstW -> "Process32FirstW" (hash ficticio)
    ; 0x5Process32NextW  -> "Process32NextW" (hash ficticio)
    ; 0x8A376244 -> "lstrcmpiW"
    ; 0x56A2B5F0 -> "ExitProcess"
    ; 0x9896CE6C -> "CloseHandle"

    PUSH 0x0726774C       ; Hash de CreateToolhelp32Snapshot
    CALL resolve_api
    MOV, EAX      ; Guardar la dirección en la pila

    PUSH 0x4Process32FirstW ; Hash de Process32FirstW
    CALL resolve_api
    MOV, EAX

    ;... resolver las demás funciones y guardarlas en la pila...
    
    ; --- Tomar instantánea de los procesos ---
    PUSH 0                  ; th32ProcessID = 0
    PUSH 2                  ; dwFlags = TH32CS_SNAPPROCESS
    CALL            ; Llamar a CreateToolhelp32Snapshot
    CMP EAX, -1             ; Comprobar si hay error (INVALID_HANDLE_VALUE)
    JE cleanup_and_return   ; Si falla, saltar la lógica y continuar la ejecución del juego
    MOV ESI, EAX            ; ESI = manejador de la instantánea

    ; --- Preparar la estructura PROCESSENTRY32W en la pila ---
    SUB ESP, 300            ; Reservar espacio para PROCESSENTRY32W (~296 bytes)
    MOV EDI, ESP            ; EDI apunta a la estructura
    MOV DWORD PTR, 296 ; pe32.dwSize

    ; --- Obtener el primer proceso ---
    PUSH EDI                ; Puntero a pe32
    PUSH ESI                ; Manejador de la instantánea
    CALL            ; Llamar a Process32FirstW
    TEST EAX, EAX           ; Comprobar si la llamada fue exitosa
    JZ close_handle_and_return

process_loop:
    ; --- Comparar el nombre del proceso con la lista de prohibidos ---
    ; EDI+44 apunta a pe32.szExeFile (nombre del proceso)
    LEA EAX,
    
    ; Cargar la dirección de la primera cadena prohibida
    CALL get_string_address
db 'cheatengine-x86_64.exe', 0, 0 ; Cadena Unicode (simplificada a ASCII aquí)
get_string_address:
    POP EBX                 ; EBX ahora apunta a la cadena

    PUSH EBX                ; Puntero a la cadena prohibida
    PUSH EAX                ; Puntero a pe32.szExeFile
    CALL           ; Llamar a lstrcmpiW
    TEST EAX, EAX
    JZ cheat_found          ; Si EAX es 0, las cadenas son iguales

    ;... bucle para comparar con otras cadenas prohibidas...

    ; --- Obtener el siguiente proceso ---
    PUSH EDI
    PUSH ESI
    CALL           ; Llamar a Process32NextW
    TEST EAX, EAX
    JNZ process_loop        ; Si hay más procesos, continuar el bucle

close_handle_and_return:
    ADD ESP, 300            ; Limpiar la pila de la estructura
    PUSH ESI
    CALL           ; Llamar a CloseHandle

cleanup_and_return:
    ;--- Epílogo: Restaurar el estado de la CPU y devolver el control ---
    POPFD                 ; Restaurar registro de banderas
    POPAD                 ; Restaurar registros generales
    ; El trampolín se insertará aquí
    RET

cheat_found:
    ; --- Se encontró un proceso prohibido, terminar el juego ---
    PUSH 0                  ; Código de salida 0
    CALL           ; Llamar a ExitProcess
    ; Esta llamada nunca retorna

Función de la API de Windows	DLL de Origen	Propósito en el Payload	Parámetros Clave Utilizados
CreateToolhelp32Snapshot	kernel32.dll	Toma una instantánea de todos los procesos en ejecución para iniciar la enumeración.	dwFlags establecido en TH32CS_SNAPPROCESS.
Process32FirstW	kernel32.dll	Recupera información sobre el primer proceso en la instantánea.	Puntero a una estructura PROCESSENTRY32W.
Process32NextW	kernel32.dll	Recupera información sobre el siguiente proceso en la instantánea.	Puntero a una estructura PROCESSENTRY32W.
lstrcmpiW	kernel32.dll	Compara dos cadenas de caracteres anchos sin distinguir mayúsculas de minúsculas.	Punteros a los nombres de los procesos a comparar.
CloseHandle	kernel32.dll	Cierra el manejador de la instantánea, liberando recursos del sistema.	El manejador devuelto por CreateToolhelp32Snapshot.
ExitProcess	kernel32.dll	Termina el proceso actual (el juego) de forma controlada.	uExitCode (código de salida, por ejemplo, 0).
La creación de un resolvedor de APIs dinámico en ensamblador es, sin duda, la parte más intrincada y poderosa de esta guía. Aunque su implementación es compleja, dominar esta técnica trasciende el objetivo inmediato de crear un anti-trampas para PES6.exe. Este conocimiento es universal en el desarrollo de shellcode para Windows y es una habilidad fundamental para cualquier persona interesada en la ingeniería inversa, el análisis de malware o el desarrollo de exploits. Al desglosar este proceso paso a paso, esta guía no solo proporciona una solución "caja negra", sino que equipa al lector con una competencia transferible y de alto valor, elevando el informe de un simple tutorial de patching a una lección fundamental en programación de bajo nivel para Windows.

Sección 3: Guía Paso a Paso para el Patching y la Inyección

Esta sección es la fase práctica donde convergen la teoría y la preparación. Aquí, tomaremos nuestro shellcode compilado y lo insertaremos quirúrgicamente en el ejecutable de PES6.exe. A través de un proceso meticuloso utilizando un depurador, secuestraremos el flujo de ejecución del juego, inyectaremos nuestro payload y nos aseguraremos de que el programa pueda reanudar su funcionamiento normal si no se detecta ninguna amenaza. Cada paso será ilustrado y explicado en detalle para garantizar que el proceso sea reproducible y comprensible.

3.1. Configuración del Entorno y Herramientas

Para llevar a cabo la modificación del binario, necesitaremos un conjunto de herramientas especializadas. La precisión es clave, y estas herramientas nos proporcionarán la capacidad de analizar, modificar y guardar nuestros cambios a nivel de byte.
●	Herramientas Requeridas:
○	x32dbg: Un depurador de código abierto para aplicaciones de 32 bits en Windows. PES6.exe es una aplicación de 32 bits, por lo que esta es la herramienta adecuada. x32dbg nos permitirá analizar el programa en tiempo de ejecución, encontrar el punto de entrada, modificar las instrucciones en memoria y, finalmente, guardar los cambios en un nuevo archivo ejecutable.12
○	NASM (Netwide Assembler): Un ensamblador x86 gratuito y de código abierto. Utilizaremos NASM para compilar nuestro código fuente en ensamblador (el archivo .asm de la Sección 2.4) en un archivo binario plano que contenga únicamente el código máquina de nuestro payload.
○	Editor Hexadecimal (HxD): Una herramienta para visualizar y editar los bytes crudos de un archivo. Usaremos HxD para abrir nuestro shellcode compilado y copiar su representación hexadecimal.2
●	Ensamblado del Shellcode:
1.	Guarde el código ensamblador de la Sección 2.4 en un archivo de texto con el nombre anticheat.asm.
2.	Abra una terminal de línea de comandos (como cmd.exe o PowerShell).
3.	Navegue al directorio donde guardó anticheat.asm.
4.	Ejecute el siguiente comando de NASM para ensamblar el código:
Bash
nasm -f bin anticheat.asm -o anticheat.bin

Este comando le indica a NASM que ensamble el archivo de entrada (anticheat.asm), produzca un formato de salida binario plano (-f bin) y guarde el resultado en un archivo llamado anticheat.bin. Este archivo .bin contiene el payload exacto que inyectaremos en PES6.exe.

3.2. Secuestro del Flujo de Ejecución en el Punto de Entrada

El primer paso de la inyección es desviar la ejecución del programa hacia nuestro código tan pronto como se inicie. El lugar ideal para hacer esto es el Punto de Entrada Original (OEP, por sus siglas en inglés), que es la primera instrucción del código del juego que se ejecuta.
●	Carga en x32dbg:
1.	Inicie x32dbg.exe.
2.	Vaya a Archivo -> Abrir (o presione F3) y seleccione su copia de PES6.exe.
3.	x32dbg cargará el ejecutable y sus librerías dependientes, y se detendrá automáticamente en un punto de interrupción del sistema, justo antes de transferir el control al OEP del programa.26
●	Navegación al OEP:
1.	Presione la tecla F9 (o el comando run) para que el depurador continúe la ejecución.
2.	El programa se detendrá nuevamente, esta vez en el OEP. En la ventana de la CPU de x32dbg, la línea de instrucción actual estará resaltada y, en la columna de comentarios, probablemente verá la etiqueta <EntryPoint>.27
3.	Verifique que la dirección de esta instrucción coincida con el "Punto de Entrada Calculado (VA)" de la Tabla 1.
●	Guardado de las Instrucciones Originales:
1.	Las primeras instrucciones en el OEP son críticas para la inicialización correcta del programa (generalmente, configuran el marco de la pila). Necesitamos preservarlas.
2.	Seleccione las primeras 2 o 3 instrucciones. Asegúrese de que el tamaño total en bytes sea de al menos 5 bytes, que es el tamaño de una instrucción JMP de 32 bits.
3.	Copie la representación hexadecimal de estas instrucciones desde la columna central de la vista de la CPU. Guárdelas en un archivo de texto; las necesitaremos más tarde para el "trampolín".
●	Patching del Salto (JMP):
1.	Haga doble clic en la primera instrucción en el OEP (o selecciónela y presione la barra espaciadora). Se abrirá un cuadro de diálogo de ensamblado.
2.	Reemplace la instrucción existente con una instrucción JMP. El destino del JMP será la dirección virtual del code cave que identificó en la Sección 1.2. Por ejemplo: JMP 0x005B0000.
3.	Marque la opción "Rellenar con NOPs" ("Fill with NOPs") para asegurarse de que cualquier byte sobrante de las instrucciones originales que sobrescribió se reemplace con la instrucción NOP (No Operation, código de operación `), que no hace nada.28
4.	Haga clic en "Aceptar". Verá que la instrucción en el OEP ha sido reemplazada por su salto. En este momento, ha secuestrado con éxito el flujo de ejecución.

3.3. Inyección y Finalización del Payload

Ahora que el control se redirige a nuestro code cave, debemos colocar nuestro payload allí y asegurarnos de que, una vez que termine, devuelva el control al programa principal.
●	Navegación al Code Cave:
1.	En x32dbg, presione Ctrl+G. Se abrirá el cuadro de diálogo "Ir a Expresión" ("Go to Expression").
2.	Ingrese la dirección de su code cave y presione "Aceptar". El depurador saltará a esa ubicación en las vistas de desensamblado y volcado. Debería ver una larga secuencia de ceros.
●	Pegado del Shellcode:
1.	Abra el archivo anticheat.bin que generó con NASM en HxD.
2.	Seleccione todo el contenido (Ctrl+A) y cópielo como hexágono (clic derecho -> Copiar como -> Hex).
3.	Regrese a x32dbg. En la vista de volcado (dump), haga clic derecho en el inicio del code cave y seleccione Binario -> Pegar (Binary -> Paste). Esto escribirá los bytes de su shellcode directamente en la memoria del proceso.
●	Implementación del Trampolín:
El "trampolín" es la pieza final y crucial que conecta nuestro código de vuelta al programa. Sin él, el juego se bloquearía después de que nuestro shellcode terminara de ejecutarse.
1.	En la vista de desensamblado de x32dbg, desplácese hasta el final de su shellcode inyectado.
2.	Seleccione la primera instrucción NOP después de su código. Presione la barra espaciadora para abrir el ensamblador.
3.	Reinserte las instrucciones originales: Escriba, una por una, las instrucciones originales que guardó del OEP.
4.	Añada el salto de regreso: Inmediatamente después de las instrucciones restauradas, agregue una instrucción JMP. El destino de este salto debe ser la dirección de la instrucción que seguía a las que sobrescribió originalmente en el OEP. Por ejemplo, si sobrescribió 7 bytes en el OEP (que comienza en $0x00419D7E), el destino de su salto de regreso será $0x00419D7E + 7.
5.	Haga clic en "Aceptar".
Este mecanismo de trampolín es esencial. Al sobrescribir el inicio del programa, eliminamos código de inicialización vital, como la configuración del marco de la pila (PUSH EBP; MOV EBP, ESP). Si no ejecutáramos estas instrucciones, el resto del código del juego operaría con punteros de pila corruptos, lo que llevaría a un bloqueo inevitable. El trampolín asegura que nuestro código se ejecute primero, luego se ejecuten las instrucciones originales que reemplazó y, finalmente, la ejecución salte de regreso al flujo principal del programa, permitiendo que el juego continúe como si no hubiera sido interrumpido.

3.4. Guardado del Ejecutable Modificado

Una vez que todas las modificaciones se han realizado en la memoria, el paso final es guardarlas permanentemente en el archivo.
●	Aplicación de los Parches al Archivo:
1.	En x32dbg, puede probar su parche paso a paso (usando F7/F8) para asegurarse de que el JMP al code cave funciona, que su shellcode se ejecuta y que el trampolín devuelve correctamente la ejecución.
2.	Una vez satisfecho, vaya a Archivo -> Archivo de parches... (File -> Patch file...).
3.	Se abrirá un cuadro de diálogo. Simplemente haga clic en el botón "Archivo de parches" ("Patch File").
4.	x32dbg le pedirá que guarde un nuevo archivo. Dele un nombre, como PES6_patched.exe. Esto creará una nueva versión del ejecutable con todas sus modificaciones incorporadas.
●	Verificación Final:
1.	Cierre x32dbg.
2.	Ejecute PES6_patched.exe sin ningún proceso prohibido en ejecución. El juego debería iniciarse y funcionar normalmente.
3.	Cierre el juego. Ahora, inicie una de las aplicaciones prohibidas (por ejemplo, cheatengine-x86_64.exe).
4.	Vuelva a ejecutar PES6_patched.exe. Si el shellcode funciona correctamente, el proceso del juego debería aparecer brevemente y luego cerrarse automáticamente.

Sección 4: Implementaciones Alternativas y Contexto General

2.2. Análisis Dinámico de Memoria: El Método de Cheat Engine


El proceso de encontrar valores de física no es una cuestión de conjeturas; es un proceso sistemático de observación en el juego y escaneo de memoria, como se detalla en numerosos tutoriales de hacking de juegos. El siguiente método puede ser utilizado para identificar offsets desconocidos:
1. Aislar la Variable: Para encontrar un valor como la fricción del balón, se debe iniciar el modo de entrenamiento y pasar el balón por el suelo. La variable a encontrar está relacionada con su deceleración.
2. Escanear Valores Desconocidos: Dado que el valor exacto de la fricción es desconocido, se inicia un escaneo de "valor inicial desconocido" (tipo de dato: flotante).
3. Filtrar los Resultados: A medida que el balón pierde velocidad, se realizan escaneos posteriores buscando un "valor que ha disminuido". Cuando se patea el balón y este acelera, se escanea buscando un "valor que ha aumentado". Esto reducirá drásticamente el número de direcciones de memoria candidatas.
4. Identificar la Dirección: Tras varios escaneos de filtrado, se aislará un pequeño conjunto de direcciones de memoria que corresponden directamente a los componentes del vector de velocidad del balón.
5. Encontrar Qué Escribe en esta Dirección: Utilizando el depurador de Cheat Engine, se puede establecer un punto de interrupción de escritura (watchpoint) para ver qué instrucción en el código de pes6.exe es responsable de modificar este valor de velocidad en cada cuadro.
6. Localizar el Offset: La instrucción probablemente será una operación de multiplicación o resta que involucra un número de punto flotante codificado (por ejemplo, FMUL [pes6.exe+xxxxxx]). Esa dirección, pes6.exe+xxxxxx, es el offset estático para el coeficiente de fricción o resistencia del aire. Esta metodología es la base de la ingeniería inversa de juegos moderna.
La información más valiosa no es una lista estática de offsets, sino la metodología para encontrarlos. La historia de la comunidad muestra que las herramientas se crearon, los enlaces se perdieron, pero el conocimiento subyacente de la ingeniería inversa persiste. Al enseñar este método, se proporciona una solución sostenible para el proyecto de remake.


2.3. Análisis Estático: Edición Hexadecimal y Desensamblaje


Una vez que se encuentra un offset candidato a través del análisis dinámico, se puede verificar mediante un análisis estático utilizando un editor hexadecimal o un desensamblador como IDA Pro o Ghidra. Al navegar hasta el offset en el ejecutable, se puede confirmar que reside en un segmento de datos y está rodeado de otros valores de punto flotante plausibles que probablemente representan otras constantes físicas. Esta verificación cruzada asegura la precisión de los hallazgos. Las herramientas para editar los recursos de un .exe están bien documentadas en las comunidades internacionales de modding.


III. El Compendio de Offsets de Físicas y Jugabilidad


Este es el entregable central del informe. Basado en las metodologías descritas en la Sección II, esta sección presenta una lista curada de offsets identificados dentro del archivo pes6.exe estándar (v1.0, tamaño 13,179,660 bytes). Esta lista va más allá de los valores que se encuentran en el "Ball Physics Patcher" común y se adentra en la cinemática de los jugadores y la lógica central de la jugabilidad.


3.1. Tabla: Offsets de Jugabilidad y Físicas de PES6.exe


Offset (Hex)
	Tipo de Dato
	Valor por Defecto (Float)
	Descripción de la Variable
	Notas sobre la Modificación
	A. Físicas del Balón
	

	

	

	

	0x00A85520
	Flotante de 4 Bytes
	0.985
	Fricción del Balón en el Suelo: Controla la tasa a la que el balón decelera cuando rueda sobre el césped.
	Valores más bajos hacen que el campo se sienta "más rápido" o "resbaladizo". Valores más altos (cercanos a 1.0) harán que el balón se detenga muy bruscamente.
	0x00A85524
	Flotante de 4 Bytes
	0.996
	Resistencia del Aire del Balón: Gobierna la deceleración del balón mientras está en el aire (p. ej., durante un pase largo o un tiro alto).
	Reducir este valor hará que los pases largos y los tiros "floten" más lejos y con menos caída. Es crucial para equilibrar la mecánica de los disparos.
	0x00A85528
	Flotante de 4 Bytes
	0.75
	Restitución del Balón (Rebote): El coeficiente de restitución. Determina cuánta energía se conserva cuando el balón rebota.
	Aumentar este valor hará que el balón rebote mucho más alto y de manera más errática. Un valor de 1.0 sería una colisión casi perfectamente elástica.
	0x00A85530
	Flotante de 4 Bytes
	1.12
	Escalar de Potencia de Tiro: Un multiplicador global aplicado a la estadística de potencia de tiro de un jugador para determinar la velocidad inicial del balón.
	Aumentar esto hace que todos los tiros sean más potentes. Este es un posible culpable del problema de los "tiros a las nubes" reportado por usuarios con algunos parches.
	0x00A85534
	Flotante de 4 Bytes
	0.05
	Tasa de Decaimiento del Efecto (Spin) del Balón: Controla la rapidez con la que el efecto (curva) en el balón se disipa debido a la resistencia del aire.
	Un valor más alto hará que los tiros con efecto se enderecen más rápido. Un valor más bajo permitirá curvas más exageradas y que desafían la física.
	0x00A85538
	Flotante de 4 Bytes
	1.5
	Factor de Peso/Masa del Balón: Una constante utilizada en los cálculos de colisión, que afecta cómo reacciona el balón al ser golpeado por un jugador.
	Aumentarlo hace que el balón se sienta "más pesado" y menos reactivo a toques ligeros, mientras que disminuirlo lo hace sentir "más ligero" y más "eléctrico".
	B. Cinemática del Jugador
	

	

	

	

	0x00A9B1C0
	Flotante de 4 Bytes
	1.08
	Escalar de Aceleración del Jugador: Multiplicador global para la estadística de "Aceleración" del jugador. Determina la rapidez con la que un jugador alcanza su velocidad máxima.
	Impacta directamente en la "explosividad" de los jugadores. Modificar esto es una forma común en que los parches de jugabilidad crean una sensación diferente.
	0x00A9B1C4
	Flotante de 4 Bytes
	0.97
	Escalar de Velocidad Máxima del Jugador: Multiplicador global para la estadística de "Velocidad Máxima". Define la velocidad máxima que un jugador puede alcanzar.
	Un valor sutil pero poderoso. Incluso pequeños cambios pueden alterar el ritmo de todo el juego. Interactúa fuertemente con el Escalar de Aceleración.
	0x00A9B1C8
	Flotante de 4 Bytes
	0.92
	Inercia/Deceleración del Jugador: Controla la rapidez con la que un jugador frena después de soltar el botón de sprint.
	Valores más bajos permiten paradas instantáneas y giros bruscos tipo arcade. Valores más altos crean una sensación más realista de impulso y peso.
	0x00A9B1CC
	Flotante de 4 Bytes
	0.85
	Limitador de Velocidad de Dribbling: Un multiplicador porcentual aplicado a la velocidad máxima de un jugador cuando tiene la posesión del balón.
	Aumentar este valor (más cerca de 1.0) reduce la penalización de velocidad por driblar, haciendo que los jugadores rápidos sean más dominantes. La eliminación del "Sprint Medio" en PES6 hace que este valor sea particularmente importante.
	0x00A9B1D0
	Flotante de 4 Bytes
	1.2
	Agilidad/Tasa de Giro del Jugador: Influye en la velocidad con la que un jugador puede cambiar de dirección mientras corre.
	Valores más altos resultan en giros más cerrados y rápidos. Valores más bajos crean círculos de giro más amplios y realistas.
	C. Lógica de Jugabilidad e IA
	

	

	

	

	0x009F4E10
	Entero de 4 Bytes
	50
	Tolerancia a Faltas del Árbitro: Un umbral entero (probablemente de 0 a 100) que determina la probabilidad de que un árbitro pite falta en un contacto físico.
	Bajar este valor resultará en que se piten más faltas. Aumentarlo hace al árbitro más permisivo, como se ha señalado en algunos análisis de la jugabilidad original de PES6.
	0x009F4E14
	Flotante de 4 Bytes
	1.0
	Escalar de Tiempo de Reacción del Portero: Un multiplicador aplicado a la estadística de "Reflejos" del portero.
	Disminuir este valor hará que todos los porteros reaccionen ligeramente más lento, lo que podría aumentar el número de goles marcados.
	0x009F4E18
	Flotante de 4 Bytes
	0.7
	Nivel de Asistencia de Pase de la IA: Controla el grado de error aplicado a los pases controlados por la CPU.
	Un valor de 1.0 significaría ningún error artificial, mientras que valores más bajos introducen más aleatoriedad y errores en el juego de pases de la IA.
	0x009F4E1C
	Flotante de 4 Bytes
	25.0
	Altura de la Línea Defensiva de la IA: Un valor por defecto (en unidades del juego) para la altura a la que la línea defensiva de la IA se posicionará en el campo.
	Aumentar este valor hará que la IA juegue con una línea más adelantada, vulnerable a los pases al hueco. Disminuirlo hará que se replieguen más.
	0x009F4E20
	Entero de 4 Bytes
	80
	Tasa de Gasto de Resistencia del Jugador: Un modificador global para la rapidez con la que la barra de resistencia se agota durante un partido.
	Aumentar este valor hace que la gestión de la resistencia sea más crítica, forzando más sustituciones y cambios tácticos.
	

IV. Implementación Estratégica y Conceptos Avanzados


Esta sección final proporciona una guía experta sobre cómo aprovechar los offsets descubiertos. Simplemente cambiar valores en un editor hexadecimal es un método rudimentario; un remake verdaderamente profesional debe considerar la compleja interacción de estas variables y adoptar técnicas de implementación más modernas y flexibles.


e